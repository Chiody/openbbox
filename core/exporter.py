"""
Prompt Exporter â€” extracts clean prompt sequences and generates reusable scripts.
This is the "Asset Replication" feature of OpenBBox.
"""

from __future__ import annotations

import json
from datetime import datetime
from typing import Optional

from core.models import PulseNode


class PromptExporter:
    """Exports prompt sequences in various formats for reuse in other projects."""

    @staticmethod
    def to_markdown(nodes: list[PulseNode], project_name: str = "") -> str:
        """Generate a Markdown 'Director's Script' from a sequence of PulseNodes."""
        lines: list[str] = []
        title = project_name or "OpenBBox Prompt Script"
        lines.append(f"# {title}")
        lines.append("")
        lines.append(f"> Generated by OpenBBox | {datetime.utcnow().strftime('%Y-%m-%d %H:%M')}")
        lines.append(f"> Total prompts: {len(nodes)}")
        lines.append("")
        lines.append("---")
        lines.append("")

        for i, node in enumerate(nodes, 1):
            lines.append(f"## Step {i:03d}")
            lines.append("")
            lines.append(f"**Source:** {node.source.ide.value}")
            lines.append(f"**Time:** {node.timestamp.strftime('%Y-%m-%d %H:%M:%S')}")
            lines.append("")
            lines.append("### Prompt")
            lines.append("")
            lines.append(f"```")
            lines.append(node.intent.raw_prompt)
            lines.append(f"```")
            lines.append("")

            if node.execution.ai_response:
                lines.append("### AI Response")
                lines.append("")
                response_preview = node.execution.ai_response
                if len(response_preview) > 1000:
                    response_preview = response_preview[:997] + "..."
                lines.append(response_preview)
                lines.append("")

            if node.execution.diffs:
                lines.append("### Code Changes")
                lines.append("")
                for diff in node.execution.diffs:
                    lines.append(f"- `{diff.file_path}` ({diff.change_type})")
                lines.append("")

            lines.append("---")
            lines.append("")

        return "\n".join(lines)

    @staticmethod
    def to_prompt_list(nodes: list[PulseNode]) -> str:
        """Extract only the clean prompts, one per line, for quick copy-paste."""
        lines: list[str] = []
        for i, node in enumerate(nodes, 1):
            lines.append(f"STEP {i:03d}:")
            lines.append(node.intent.raw_prompt)
            lines.append("")
            lines.append("---")
            lines.append("")
        return "\n".join(lines)

    @staticmethod
    def to_json(nodes: list[PulseNode], project_name: str = "") -> str:
        """Export as a structured JSON file (.pulse format)."""
        data = {
            "format": "openbbox-pulse-v1",
            "project": project_name,
            "generated_at": datetime.utcnow().isoformat(),
            "total_steps": len(nodes),
            "sequence": [],
        }
        for i, node in enumerate(nodes, 1):
            step = {
                "index": i,
                "source": node.source.ide.value,
                "timestamp": node.timestamp.isoformat(),
                "prompt": node.intent.raw_prompt,
                "clean_title": node.intent.clean_title,
                "ai_response_preview": (
                    node.execution.ai_response[:500]
                    if node.execution.ai_response
                    else ""
                ),
                "changed_files": node.execution.affected_files,
            }
            data["sequence"].append(step)
        return json.dumps(data, ensure_ascii=False, indent=2)

    @staticmethod
    def filter_by_ids(nodes: list[PulseNode], ids: list[str]) -> list[PulseNode]:
        """Filter nodes by a list of IDs (for selective export)."""
        id_set = set(ids)
        return [n for n in nodes if n.id in id_set]
